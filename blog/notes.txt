

=== Migrating an app to Swift 4

A lot has change since Swift 2:
- guard 
- JSON handling, using Codable

Also new techniques have become popular:
- MVVM

Other have declined in popularity:
- RxSwift

=== Dependencies

Depeendencies in the project were managed by CocoaPod. It is a pretty capable dependency manager for iOS projects, though I may prefer to use Carthage these days. Carthage is more lightweight and gives more control to the developer.

in 2015 RxSwift was booming. I had practiced a bit the Objective-C version: ReactiveCocoa in the past. The problem here is that I wanted to use it everywhere. Specially in this case, this framework is used only at one place in the code. RxSwift is a big dependency; it will shape the way you are doing your project so it should not be taken as a light decision. Some developers hate it with some reasons (in debug, have you ever seen how huge is a RxSwift call stack ?). Here the choice should be obvious, there is no reason at all to have it in a demo project like that.

UIWebView has been deprecated since a long time, it is time to switch. WKWebView is a no brainer, the change is easy. However in some case, I was using a web view just for rendering some attributed text with sometime a link in it, maybe something cleaner can be done ? Also, web view take some time to display at first, this could be changed with an NSAttributedString.

== Rendering HTML into an NSAttributedString

At some point, every iOS developer will encounter this situation: you need to display some text that is provided with some HTML formating. 
Also this text can have some HTML link in it and user should be able to follow the link.
Here I had choosen to use a version of the Mustache library for performing this task.

The template looks like that:

<html>
<style type="text/css">
body {
    font-family: "-apple-system", "sans-serif";
    font-size: 14px;
}
h2 {
    font-size: 17px;
}
</style>
<body>
    <hr>
    <h2>Concern :</h2>
    <p>{{{concern}}}</p>
</body>
</html>


First problem, the GRMustache.swift library is not maintened anymore and does not compile with Swift 4.
Ok, I can switch back to the GRMustache library in Objective-C.

Then I realized that after all, it is a bit of overkill, because nowadays we have multi-line strings in Swift and
the string interpolation can perfectly do the job:

struct SimpleRenderer {
    static func render(concern: String) -> String {
        return """
<html>
<style type="text/css">
body {
    font-family: "-apple-system", "sans-serif";
    font-size: 14px;
}
h2 {
    font-size: 17px;
}
</style>
<body>
    <hr>
    <h2>Concern :</h2>
    <p>\(concern)</p>
</body>
</html>
"""
    }
}

Next step: after all, do we really need to instantiate a web view (WKWebView) just for rendering some text ?
we can use NSAttributedString for that task.


let options = [NSAttributedString.DocumentReadingOptionKey.documentType:
                        NSAttributedString.DocumentType.html]

let attributedString = try? NSMutableAttributedString(data:htmlData,
                                                        options: options,
                                                        documentAttributes: nil)

Then how to get the link ? Easy, NSAttributedString has already done the parsing of the HTML, we can retrieve the link from it:

extension NSAttributedString {
    var links: [URL] {
        var links = [URL]()
        self.enumerateAttribute(.link, in: NSRange(0..<self.length), options: []) { value, range, stop in
            if let value = value as? URL {
                links.append(value)
            }
        }
        return links
    }
}

now you can install a UITapGestureRecognizer on the label, and open a Safari view when the user tap the label.

        detailConcernLabel.attributedText = attributedString
        detailConcernLabel.isUserInteractionEnabled = true
        detailConcernLabel.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(tapConcern)))

    @objc func tapConcern() {
        let attributedString = detailConcernLabel.attributedText!
        guard let link = attributedString.links.first else { return }
        let safariVC = SFSafariViewController(url: link)
        present(safariVC, animated: true, completion: nil)
    }

=== Supporting the iPad

The initial customer for this app wanted to support the iPad. It could be a perfect valid choice, even if we could wonder if people that go fishing takes their iPad with them. 
Probably they rather go fishing with a phone than a tablet.
Anyway, as I convert this app to an exercice aimed at instructional purpose, let's not be distracted by the support of
multiple device form factor. Maybe that will be a goal for a future tutorial.
So I will remove the UISplitViewController and reduce the list of supported devices and orientations.

Also supporting multiple interface orientations has some impact on the development time and should be considered carrefully.
Most people are fine using their iPhone app in portrait only mode.

There is one exception here, displaying the fullscreen image of a fish works better in landscape, 
so I use a 90 degree rotated view for this (see ImageViewController)

=== using Flow/ Coordinator pattern instead of segue (UIStoryboardSegue)

benefits of segue: they looks nice in Storyboards

Flow pattern (sometime named Coordinator pattern) improve decoupling between view controller

=== MVVM

Model - View - View Model

- reduce view controller size
- improve testability

Here is a brief summary:

MVC (Model / View/ Controller) is a good and mature paradigm. Usually this is a good starting point for a new screen.
However, as view complexity increase over time, it is sometimes good to extract some of the presentation logic of the view controller into an other object, the view model. 
As the name implies it is a model which purpose is to compute and store all the information needed for the view: 
strings or attributed strings for label, provide image for image view, etc ..
This paradigm is called MVVM (Model / View / ViewModel)

More info here: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel

in my project, I had a DetailViewController that could benefit a bit of refactor. I extracted most of the presentation logic into a view model named DetailViewModel.

=== ImageLoader

You should do the loading and decoding of images in the background.
There is plenty of library for doing that, but you can achive pretty good results by using 
some simple tools: NSOperationQueue for background processing, NSCache for image caching.

=== Moving dependencies to Carthage

#github "chiahsien/CHTCollectionViewWaterfallLayout"
github "u1tkzw/CHTCollectionViewWaterfallLayout" "develop"
#github "airbnb/MagazineLayout"
github "Darkseal/DownPicker"

carthage update --no-build 

carthage bootstrap --cache-builds --platform iOS
